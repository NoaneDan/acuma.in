# Facebook Event Import:
***
## Description:
Get all the upcoming events from a given location. The locations is
sent as a Facebook Location ID.
***
## Create an importer:
To create a new importer you must call the constructor with the
following parameters:
+ **location_id** - the id of the location, returned by FacebookLocationImport.
+ **access token** - string, generated by FacebookAuth.

The generated app access token expires in 60 days. When it expires all
the responses from the API will have a status code of *400* and will
contain:

    `{
        "error": {
            "message": "Error validating access token: Session has expired at unix 
                        time SOME_TIME. The current unix time is SOME_TIME.", 
            "type": "OAuthException", 
            "code": 190
        }
    }`
***
## Get events:
To import all the upcoming events from the location call **getEvents()**
method. This makes a **GET** request to Facebook Graph API at
***'https://graph.facebook.com/v2.7/{location_id}/events'***.

The only query parameter for the first request is *access_token*.

The events are returned in reverse chronological order (upcoming events
come before recent and recent before older ones).
The list of events is on one or more pages, each containing the url
of the next one. To check if there is another page the script verifies
if the *paging* memeber of the object returned by Facebook Graph API
has the *next* memeber set. If it is set it will be a *url* to the next page.
This *url* is parsed in order to extract the *after* parameter and the
*limit* parameter, which represents the maximum number of events on
the next page.
*after* and *limit* are added to the query and the request for the
next page is made.

The *after* parameter tells Graph API to return on the next page only events
that are 'after' (in reverse chronological order) the last one on the previous
page.

    `// the events are on multiple pages
    // we are given the url of the next page, if exists
    if (isset($events->paging->next)) {
        $url = parse_url($events->paging->next);
        parse_str($url['query']);
                
        $params['query']['after'] = $after;
        $params['query']['limit'] = $limit;
                
        if (isset($pretty)) {
            $params['query']['pretty'] = $pretty;
        }
    }`

This is repeated as long as there are more pages (the *next* member of *paging*
is set) and there is at least one upcoming event on the page.

After each successful request **getLocations()** calls **processEvents()** method
with the object received from the API. **processEvents()** returns all the events
that are upcoming and only the relevant data about them. If the list is empty then
there were no upcoming events on the page, so the algorithm can stop, because all
events left happend already.

If the list of processed events is not empty the algorithm will call **getAdditionalData()**
and **addToDB()** to save the events to the database.

    `$processed_events = $this->processEvents($events);
            
    // if all the start dates of the returned events are older than the current date
    // the list with proccess_events will be empty.
    if ($processed_events !== []) {
        $processed_events = $this->getAdditionalData($processed_events);
        $this->saveToDB($processed_events);
    }`
***
## Process events:
This method is called after Graph API returns a list of events, to
extract only the relevant data from each of them.

If the algorithm encounters an event that has a *start date* that is
older than the current date it *breaks* out of the loop that iterates
through the list of events.

    `if (strtotime($event->start_time) < time()) {
        break;
    }`
    
Not all data that the script wants to extract, such as 'description' and
'end_time' is set for every event.
***
## Get additional data:
After the list of events is processed **getEvents()** calls
**getAdditionalData()**. This method makes a **GET** request for
additional data for each event at
***'https://graph.facebook.com/v2.7/{event id}'***.

The query string contains the access_token and the additinal
fields separated by commas:

    `'query' => [
        'access_token' => $this->access_token,
        'fields' => implode(',', $fields)    
    ]`

The additional data fields are stored in the *$fields* variable:

    `$fields = [
        'category',
        'type',
        'attending_count',
        'interested_count',
        'maybe_count',
        'declined_count',
        'is_canceled',
        'ticket_uri'
    ];`
    
Where:
+ **category** - the category of the event (ART_EVENT, FESTIVAL_EVENT, etc.)
+ **type** - private, public, group or community.
+ **attending_count** - number of people attending the event
+ **interested_count** - number of people interested in the event
+ **maybe_count** - number of people that might come
+ **declined_count** - number of people that declined an invitation
+ **is_canceled** - whether the event has been canceled or not
+ **ticket_uri** - the link users can visit to buy a ticket to this event

The response will be a **JSON** object containing all the fields that
were required and which were set for the event, plus the id of the event.

    `$data = json_decode((string) $response->getBody());
    foreach ($data as $key => $value) {
        if ($key === 'id') {
            continue;
        }
                
        $processed_event[$key] = $value;
    }`

The algorithm adds all the additional data found to each event from the list
and then returns the list.
***
## Save to database:
After the events are processed and additional data is added
**getEvents()** calls the **saveToDB()** method with the list of
events.

Each event is stored in the database if it doesn't exist and if
it exists it is updated in case the organizer made some changes
to the original post.