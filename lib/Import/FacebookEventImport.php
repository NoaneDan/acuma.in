<?php
/**
 * Copyright 2016 [e-spres-oh]
 * This file is part of Acuma.in
 *
 * Acuma.in is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Acuma.in is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Acuma.in.  If not, see <http://www.gnu.org/licenses/>.
 */

namespace AcumaIn\Import;

use GuzzleHttp\Client;
use GuzzleHttp\Exception\ClientException;
use GuzzleHttp\Exception\ConnectException;
use Cocur\Slugify\Slugify;


class FacebookEventImport {
    
    protected $city;
    protected $access_token;
    
    
    public function __construct($city, $access_token) {
        
        /* Description: Create a new instance of FacebookEventImport.
         * Input: $city - the city from which to import events
         *        $access_token - (string) the access token to FacebookGraphAPI generated by FacebookAuth.
         */
        
        $this->city = $city;
        $this->access_token = $access_token;
    }
    
    
    public function getEventsFromAllLocations() {
        
        $locations = $this->getAllLocations();
        foreach ($locations as $location) {
            $this->getEventsFromLocation($location->id);
        }
    }
    
    
    protected function getAllLocations() {
        
        $locations = \ORM::for_table('fb_location')
            ->select('location_id', 'id')
            ->where('city_id', $this->city->id)
            ->where('blocked', 'no')
            ->find_many();
            
        return $locations;
    }
    
    
    protected function getEventsFromLocation($locationID) {
        
        /* Description: Make a GET request for events at a given location.
         */
        
        $params = [
            'query' => [
                'access_token' => $this->access_token
            ]
        ];
        
        $client = new Client(['base_uri' => 'https://graph.facebook.com']);
        $retry = false;
        do {
            try {
                $response = $client->request('GET', "/v2.7/$locationID/events", $params);
                $retry = false;
            }
            catch (ConnectException $e) {
                $retry = true;
                continue; 
            }
            catch (ClientException $e) {
                // 100 = location no longer exists
                $error = json_decode((string) $e->getResponse()->getBody());
                if ($error->error->code === 100) { 
                    $this->removeLocation($locationID);
                    
                    return;
                }
                else {
                    throw $e;
                }
            }
        
            if ($response->getStatusCode() !== 200) {
                throw new \UnexpectedValueException("Response status code returned:\n$response->getStatusCode()\nResponse body:$response->getBody()");
            }
            
            $events = json_decode((string) $response->getBody());
            $processed_events = $this->processEvents($events, $locationID);
            
            // if all the start dates of the returned events are older than the current date
            // the list with proccess_events will be empty.
            if ($processed_events !== []) {
                $processed_events = $this->getAdditionalData($processed_events);
                $this->saveToDB($processed_events);
            }
            
            // the events are on multiple pages
            // we are given the url of the next page, if exists
            if (isset($events->paging->next)) {
                $url = parse_url($events->paging->next);
                parse_str($url['query']);
                
                $params['query']['after'] = $after;
                $params['query']['limit'] = $limit;
                
                if (isset($pretty)) {
                    $params['query']['pretty'] = $pretty;
                }
            }
        } while($retry || ($processed_events !== [] && isset($events->paging->next)));
    }
    
    
    protected function removeLocation($locationID) {
        
        $location = \ORM::for_table('fb_location')
            ->where('location_id', $locationID)
            ->find_one();
            
        $location->delete();
    }
    
    
    private function processEvents($events, $locationID) {
        
        /* Description: Process the events returned by FacebooGraphAPI
         */
        
        $slugify = new Slugify();
        $processed_events = [];
        
        foreach ($events->data as $event) {
            if (strtotime($event->start_time) < time()) {
                break;
            }
            
            $processed_event = [
                'name' => $event->name,
                'start_time' => date('Y-m-d h:i:s', strtotime($event->start_time)),
                'event_id' => $event->id,
                'facebook_url' => 'https://facebook.com/'.$event->id,
                'slug' => $slugify->slugify($event->name)
            ];
            
            if (isset($event->description)) {
                $processed_event['description'] = $event->description;
            }
            
            if (isset($event->end_time)) {
                $processed_event['end_time'] = date('Y-m-d h:i:s', strtotime($event->end_time));
            }
            
            $location = \ORM::for_table('fb_location')
                ->select('id', 'id')
                ->where('location_id', $locationID)
                ->find_one();
                
            $processed_event['location_id'] = $location->id;
            
            $processed_events[] = $processed_event;
        }
        
        return $processed_events;
    }
    
    
    private function getAdditionalData($processed_events) {
        
        /* Description: Make an additional GET request for additional data
         * regarding an event.
         * Input: $processed_events - (array) the events after being processed.
         * Output: $processed_events - (array) the processed events with the additional data
         *         if found.
         */
        
        $fields = [
            'category',
            'type',
            'attending_count',
            'interested_count',
            'maybe_count',
            'declined_count',
            'is_canceled',
            'ticket_uri'
        ];
            
        $params = [
            'query' => [
                'access_token' => $this->access_token,
                'fields' => implode(',', $fields)    
            ]
        ];
        
        $client = new Client(['base_uri' => 'https://graph.facebook.com']);
        foreach ($processed_events as &$processed_event) {            
            while (!$this->getAdditionalDataFor($processed_event, $client, $params));    // retry if not successful
        }
        
        return $processed_events;
    }
    
    
    protected function getAdditionalDataFor(&$processed_event, $client, $params) {
        
        try {
            $response = $client->request('GET', "/v2.7/$processed_event[event_id]", $params);
        }
        catch (ConnectException $e) {
            return false;
        }
        
        if ($response->getStatusCode() !== 200) {
            throw new \UnexpectedValueException("Response status code returned:\n$response->getStatusCode()\nResponse body:$response->getBody()");
        }
        
        $data = json_decode((string) $response->getBody());
        foreach ($data as $key => $value) {
            if ($key === 'id') {
                continue;
            }
            else if ($key === 'ticket_uri') {
                $value = preg_replace('/http:/', 'https:', $value);
            }
            
            $processed_event[$key] = $value;
        }
        
        return true;
    }
    
    
    private function saveToDB($processed_events) {
        
        /* Description: Save the events after being processed and additional data found.
         * Input: $processed_events - (array) the events
         */
        
        foreach ($processed_events as $processed_event) {
            
            $found = \ORM::for_table('fb_event')
                ->select('id', 'id')
                ->where('event_id', $processed_event['event_id'])
                ->find_one();
                
            if ($found !== false) {
                $event = \ORM::for_table('fb_event')
                    ->find_one($found->id);
                    
                $event->set($processed_event);
                $event->save();
                
                $new_entry = \ORM::for_table('timeline')
                    ->where('source', 'fb_event')
                    ->where('source_id', $event->id)
                    ->find_one();
                    
                $new_entry->source_timestamp = $event->start_time;
                $new_entry->save();
            }
            else {
                $new_event = \ORM::for_table('fb_event')
                    ->create();
                
                $new_event->set($processed_event);
                $new_event->save();
                
                // insert post into timeline table
                $new_entry = \ORM::for_table('timeline')->create();
                
                $new_entry->source = 'fb_event';
                $new_entry->source_id = $new_event->id;
                $new_entry->source_timestamp = $new_event->start_time;
                $new_entry->source_user_id = $new_event->event_id;
                $new_entry->blocked = 'no';
                $new_entry->city_id = $this->city->id;
                $new_entry->save();
            }
        }
    }
}